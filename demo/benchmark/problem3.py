# # Problem 3: Inflation and Active Contraction of a Ventricle
#
# This example implements Problem 3 from the cardiac mechanics benchmark suite [Land et al. 2015].
#
# ## Problem Description
#
# **Geometry**:
# The same truncated ellipsoid as in Problem 2.
#
# **Microstructure**:
# A spatially varying fiber field.
# * $\alpha_{endo} = +90^\circ$
# * $\alpha_{epi} = -90^\circ$
# * The fiber angle varies linearly across the wall thickness.
#
# **Material**:
# Transversely Isotropic Guccione material.
# * Constitutive parameters: $C = 2.0$ kPa, $b_f = 8.0$, $b_t = 2.0$, $b_{fs} = 4.0$.
# * Incompressible.
#
# **Active Contraction**:
# An active stress $T_a$ is applied along the fiber direction.
#
# **Loading Protocol**:
# 1.  **Inflation**: Increase cavity pressure $P$ to 15 kPa.
# 2.  **Contraction**: While maintaining pressure, increase active tension $T_a$ to 60 kPa.
#     *(Note: The benchmark describes these as varying curves, here we usually perform a coupled ramp or sequential steps).*
#
# ---

from pathlib import Path
from mpi4py import MPI
import dolfinx
import numpy as np
import math
import cardiac_geometries
import pulse

# ## 1. Geometry and Fibers
# We regenerate the mesh with the specific fiber angles required for Problem 3 ($+90^\circ$ to $-90^\circ$).

geodir = Path("lv_ellipsoid-problem3")
comm = MPI.COMM_WORLD

if not geodir.exists():
    comm.barrier()
    cardiac_geometries.mesh.lv_ellipsoid(
        outdir=geodir,
        r_short_endo=7.0,
        r_short_epi=10.0,
        r_long_endo=17.0,
        r_long_epi=20.0,
        mu_apex_endo=-math.pi,
        mu_base_endo=-math.acos(5 / 17),
        mu_apex_epi=-math.pi,
        mu_base_epi=-math.acos(5 / 20),
        create_fibers=True,
        fiber_angle_endo=90,
        fiber_angle_epi=-90,
        fiber_space="Quadrature_6",  # High order quadrature space for accurate fiber representation
        comm=comm,
    )

geo = cardiac_geometries.geometry.Geometry.from_folder(
    comm=comm,
    folder=geodir,
)

geometry = pulse.HeartGeometry.from_cardiac_geometries(geo, metadata={"quadrature_degree": 6})

# ## 2. Constitutive Model
#
# **Material**: Transversely Isotropic Guccione.
# **Active**: Active Stress model $S_{active} = T_a (\mathbf{f}_0 \otimes \mathbf{f}_0)$.

material_params = {
    "C": dolfinx.fem.Constant(geometry.mesh, dolfinx.default_scalar_type(2.0)),
    "bf": dolfinx.fem.Constant(geometry.mesh, dolfinx.default_scalar_type(8.0)),
    "bt": dolfinx.fem.Constant(geometry.mesh, dolfinx.default_scalar_type(2.0)),
    "bfs": dolfinx.fem.Constant(geometry.mesh, dolfinx.default_scalar_type(4.0)),
}

# Note: f0, s0, n0 come from the geometry object where they were loaded from files
material = pulse.Guccione(f0=geo.f0, s0=geo.s0, n0=geo.n0, **material_params)

Ta = dolfinx.fem.Constant(geometry.mesh, dolfinx.default_scalar_type(0.0))
active_model = pulse.ActiveStress(geo.f0, activation=pulse.Variable(Ta, "kPa"))

comp_model = pulse.Incompressible()

model = pulse.CardiacModel(
    material=material,
    active=active_model,
    compressibility=comp_model,
)

# ## 3. Boundary Conditions
# * **Base**: Fixed.
# * **Pressure**: Endocardial load.

pressure = dolfinx.fem.Constant(geometry.mesh, dolfinx.default_scalar_type(0.0))
neumann = pulse.NeumannBC(
    traction=pulse.Variable(pressure, "kPa"),
    marker=geo.markers["ENDO"][0],
)

bcs = pulse.BoundaryConditions(neumann=(neumann,))

# ## 4. Solution Process
#
# We simultaneously ramp up Pressure ($0 \to 15$ kPa) and Active Tension ($0 \to 60$ kPa).
# This represents a path in the P-Ta space.

problem = pulse.StaticProblem(
    model=model, geometry=geometry, bcs=bcs, parameters={"base_bc": pulse.BaseBC.fixed},
)

# Initial solve

problem.solve()

# Ramping

target_pressure = 15.0
target_Ta = 60.0
steps = 20

pressures = np.linspace(0, target_pressure, steps)
tensions = np.linspace(0, target_Ta, steps)

vtx = dolfinx.io.VTXWriter(geometry.mesh.comm, "problem3.bp", [problem.u], engine="BP4")
vtx.write(0.0)

for i, (p, ta) in enumerate(zip(pressures, tensions)):
    if i == 0:
        continue
    print(f"Step {i}/{steps}: Pressure={p:.2f} kPa, Ta={ta:.2f} kPa")

    pressure.value = p
    Ta.value = ta

    problem.solve()
    vtx.write(float(i))
vtx.close()

# ## 5. Post-processing

# Compute apex position

U = dolfinx.fem.Function(problem.u.function_space)
U.interpolate(lambda x: (x[0], x[1], x[2]))

# Use utility to evaluate at the specific vertex tag for the apex (ENDOPT/EPIPT generated by cardiac-geometries)

endo_apex_coord = pulse.utils.evaluate_at_vertex_tag(U, geo.vfun, geo.markers["ENDOPT"][0])
u_endo_apex = pulse.utils.evaluate_at_vertex_tag(problem.u, geo.vfun, geo.markers["ENDOPT"][0])
endo_apex_pos = pulse.utils.gather_broadcast_array(geo.mesh.comm, endo_apex_coord + u_endo_apex)
print(f"\nGet longitudinal position of endocardial apex: {endo_apex_pos[0, 0]:4f} mm")

epi_apex_coord = pulse.utils.evaluate_at_vertex_tag(U, geo.vfun, geo.markers["EPIPT"][0])
u_epi_apex = pulse.utils.evaluate_at_vertex_tag(problem.u, geo.vfun, geo.markers["EPIPT"][0])
epi_apex_pos = pulse.utils.gather_broadcast_array(geo.mesh.comm, epi_apex_coord + u_epi_apex)
print(f"\nGet longitudinal position of epicardial apex: {epi_apex_pos[0, 0]:4f} mm")

# Visualization

try:
    import pyvista
except ImportError:
    print("Pyvista is not installed")
else:
    V = dolfinx.fem.functionspace(geometry.mesh, ("Lagrange", 1, (geometry.mesh.geometry.dim,)))
    uh = dolfinx.fem.Function(V)
    uh.interpolate(problem.u)

    p = pyvista.Plotter()
    topology, cell_types, geometry = dolfinx.plot.vtk_mesh(V)
    grid = pyvista.UnstructuredGrid(topology, cell_types, geometry)
    grid["u"] = uh.x.array.reshape((geometry.shape[0], 3))

    p.add_mesh(grid, style="wireframe", color="k", opacity=0.3, label="Reference")
    warped = grid.warp_by_vector("u", factor=1.0)
    p.add_mesh(warped, show_edges=True, color="blue", label="Contracted")

    p.show_axes()
    if not pyvista.OFF_SCREEN:
        p.show()
    else:
        p.screenshot("problem3.png")
